# Detailed Vulnerability Analysis with Code Examples

## 1. Path Traversal Vulnerability Analysis

### Vulnerable Code: `src/backend/pdf_manager/manager.py`

```python
def _create_file_copy(self, original_path: str, file_id: str) -> str:
    """创建PDF文件副本"""
    try:
        # VULNERABILITY: No path validation
        copy_filename = f"{file_id}.pdf"
        copy_path = os.path.join(self.pdfs_dir, copy_filename)
        
        # VULNERABILITY: shutil.copy2 follows symlinks and can traverse directories
        import shutil
        shutil.copy2(original_path, copy_path)  # DANGEROUS
        
        if os.path.exists(copy_path):
            return copy_path
        else:
            return None
    except Exception as e:
        return None
```

### Attack Scenario:
```python
# Attacker crafts malicious path
malicious_path = "../../../etc/passwd"
# Or on Windows: "..\\..\\..\\windows\\system32\\config\\sam"

# The copy operation would attempt to copy system files
# Could lead to:
# 1. Information disclosure
# 2. System file corruption
# 3. Privilege escalation
```

### Secure Implementation:
```python
def _create_file_copy(self, original_path: str, file_id: str) -> str:
    """安全创建PDF文件副本"""
    try:
        # 1. Validate and normalize path
        original_path = os.path.abspath(os.path.normpath(original_path))
        
        # 2. Check if path is within allowed directories (if applicable)
        # 3. Validate it's not a symlink
        if os.path.islink(original_path):
            raise ValueError("Symbolic links not allowed")
        
        # 4. Generate safe filename
        import re
        safe_file_id = re.sub(r'[^a-zA-Z0-9_-]', '', file_id)
        copy_filename = f"{safe_file_id}.pdf"
        copy_path = os.path.join(self.pdfs_dir, copy_filename)
        
        # 5. Additional security checks
        if not os.path.isfile(original_path):
            raise ValueError("Source is not a file")
        
        # 6. Validate file content is actually PDF
        self._validate_pdf_signature(original_path)
        
        # 7. Secure copy with explicit permissions
        import shutil
        shutil.copy2(original_path, copy_path)
        
        # 8. Set secure permissions
        os.chmod(copy_path, 0o600)  # Read/write for owner only
        
        return copy_path
    except Exception as e:
        logger.error(f"Secure file copy failed: {e}")
        return None
```

## 2. WebSocket Security Issues

### Vulnerable Code: `src/backend/websocket/server.py`

```python
def on_message_received(self, message):
    """处理收到的消息"""
    client_socket = self.sender()
    logger.info(f"📨 收到来自 {client_socket.peerPort()} 的消息: {message}")
    
    # VULNERABILITY: No size limit - DoS vector
    try:
        parsed_message = json.loads(message)  # Can fail on large messages
        # VULNERABILITY: No message structure validation
        self.message_received.emit(client_socket, parsed_message)
    except json.JSONDecodeError as e:
        logger.error(f"❌ 消息解析失败: {e}")
```

### Attack Scenarios:
```javascript
// 1. Memory exhaustion attack
const hugeMessage = '{"type":"test","data":"' + 'a'.repeat(1000000) + '"}';
ws.send(hugeMessage);

// 2. Malformed JSON attacks
ws.send('{"type":"test","data":' + '{'.repeat(10000) + '}');

// 3. Message flooding
for(let i = 0; i < 10000; i++) {
    ws.send(JSON.stringify({type: 'ping', id: i}));
}
```

### Secure WebSocket Implementation:
```python
class SecureWebSocketServer(QObject):
    MAX_MESSAGE_SIZE = 1024 * 1024  # 1MB
    MAX_CLIENTS = 100
    RATE_LIMIT = 100  # messages per minute
    
    def __init__(self):
        super().__init__()
        self.client_stats = {}  # Track client message rates
        self.message_queue_size = 1000  # Per client
        
    @pyqtSlot(str)
    def on_message_received(self, message):
        """安全处理收到的消息"""
        client_socket = self.sender()
        client_id = f"{client_socket.peerAddress().toString()}:{client_socket.peerPort()}"
        
        # 1. Rate limiting
        if not self._check_rate_limit(client_id):
            logger.warning(f"Client {client_id} exceeded rate limit")
            client_socket.close()
            return
        
        # 2. Size validation
        if len(message) > self.MAX_MESSAGE_SIZE:
            logger.error(f"Message too large from {client_id}: {len(message)} bytes")
            client_socket.close()
            return
        
        # 3. Parse with protection
        try:
            parsed_message = self._parse_json_safely(message)
            if not parsed_message:
                return
                
            # 4. Validate message structure
            if not self._validate_message_structure(parsed_message):
                logger.error(f"Invalid message structure from {client_id}")
                return
                
            # 5. Process message
            self.message_received.emit(client_socket, parsed_message)
            
        except json.JSONDecodeError as e:
            logger.error(f"JSON parse error from {client_id}: {e}")
        except Exception as e:
            logger.error(f"Message processing error from {client_id}: {e}")
    
    def _parse_json_safely(self, message):
        """安全解析JSON，防止深度嵌套攻击"""
        try:
            # Use custom JSON decoder with limits
            class SafeDecoder(json.JSONDecoder):
                def __init__(self):
                    super().__init__(object_pairs_limit=1000)
            
            data = json.loads(message, cls=SafeDecoder)
            return data
        except Exception:
            return None
    
    def _validate_message_structure(self, message):
        """验证消息结构"""
        if not isinstance(message, dict):
            return False
            
        # Required fields
        if 'type' not in message:
            return False
            
        # Validate message type
        allowed_types = ['add_pdf', 'remove_pdf', 'get_pdf_list', 'heartbeat']
        if message['type'] not in allowed_types:
            return False
            
        return True
```

## 3. XSS Vulnerability Details

### Vulnerable Code: `src/frontend/pdf-home/main.js`

```javascript
createPDFCard(pdf) {
    return `
        <div class="pdf-card" data-filename="${pdf.filename}">
            <div class="pdf-title">${pdf.title || pdf.filename}</div>
            <div class="pdf-path">${pdf.filepath || pdf.path || ''}</div>
            <div class="pdf-actions">
                <button class="btn btn-small" onclick="pdfHome.openPDF('${pdf.filename}')">打开</button>
            </div>
        </div>
    `;
}
```

### Attack Vectors:
```javascript
// Malicious PDF metadata
const maliciousPDF = {
    filename: 'safe.pdf',
    title: '<img src=x onerror=alert("XSS")>',
    path: 'C:\\<script>alert("XSS")</script>',
    notes: '<iframe src="javascript:alert(`Cookie: ${document.cookie}`)"></iframe>'
};

// When rendered, the script executes
```

### Secure Rendering Implementation:
```javascript
class SecureRenderer {
    static escapeHtml(unsafe) {
        return unsafe.toString()
            .replace(/&/g, "&amp;")
            .replace(/</g, "&lt;")
            .replace(/>/g, "&gt;")
            .replace(/"/g, "&quot;")
            .replace(/'/g, "&#039;")
            .replace(/\//g, "&#x2F;");
    }
    
    static escapeJs(unsafe) {
        return unsafe.toString()
            .replace(/\\/g, "\\\\")
            .replace(/'/g, "\\'")
            .replace(/"/g, '\\"')
            .replace(/`/g, "\\`")
            .replace(/\$/g, "\\$");
    }
    
    static createPDFCard(pdf) {
        // Escape ALL dynamic content
        const safeFilename = this.escapeHtml(pdf.filename || '');
        const safeTitle = this.escapeHtml(pdf.title || pdf.filename || '');
        const safePath = this.escapeHtml(pdf.filepath || pdf.path || '');
        
        // Use safe event handlers
        return `
            <div class="pdf-card" data-filename="${safeFilename}">
                <div class="pdf-title">${safeTitle}</div>
                <div class="pdf-path">${safePath}</div>
                <div class="pdf-actions">
                    <button class="btn btn-small" 
                            onclick="pdfHome.openPDF('${this.escapeJs(safeFilename)}')">
                        打开
                    </button>
                </div>
            </div>
        `;
    }
    
    // Alternative: Use DOM API for even safer rendering
    static createPDFCardDOM(pdf) {
        const card = document.createElement('div');
        card.className = 'pdf-card';
        card.dataset.filename = pdf.filename || '';
        
        const title = document.createElement('div');
        title.className = 'pdf-title';
        title.textContent = pdf.title || pdf.filename || '';
        card.appendChild(title);
        
        const path = document.createElement('div');
        path.className = 'pdf-path';
        path.textContent = pdf.filepath || pdf.path || '';
        card.appendChild(path);
        
        const actions = document.createElement('div');
        actions.className = 'pdf-actions';
        
        const button = document.createElement('button');
        button.className = 'btn btn-small';
        button.textContent = '打开';
        button.addEventListener('click', () => pdfHome.openPDF(pdf.filename));
        actions.appendChild(button);
        
        card.appendChild(actions);
        return card;
    }
}
```

## 4. File Upload Security Issues

### Vulnerable Code: `src/backend/pdf_manager/utils.py`

```python
@staticmethod
def is_pdf_file(file_path: str) -> bool:
    """检查文件是否为PDF格式"""
    if not file_path:
        return False
        
    # VULNERABILITY: Only checks extension
    if not file_path.lower().endswith('.pdf'):
        return False
        
    # VULNERABILITY: Doesn't validate actual content
    if not os.path.exists(file_path):
        return False
        
    return True
```

### Secure File Validation:
```python
class SecureFileValidator:
    @staticmethod
    def is_pdf_file(file_path: str) -> bool:
        """安全检查文件是否为PDF格式"""
        if not file_path:
            return False
            
        # 1. Basic checks
        if not os.path.exists(file_path):
            return False
            
        if not os.path.isfile(file_path):
            return False
            
        # 2. Check extension (but don't rely on it)
        if not file_path.lower().endswith('.pdf'):
            return False
            
        # 3. Check file signature (magic number)
        if not SecureFileValidator._check_pdf_signature(file_path):
            return False
            
        # 4. Validate PDF structure
        if not SecureFileValidator._validate_pdf_structure(file_path):
            return False
            
        # 5. Size limits
        file_size = os.path.getsize(file_path)
        if file_size > 100 * 1024 * 1024:  # 100MB limit
            return False
            
        return True
    
    @staticmethod
    def _check_pdf_signature(file_path: str) -> bool:
        """检查PDF文件签名"""
        try:
            with open(file_path, 'rb') as f:
                header = f.read(8)
                # PDF files start with %PDF-
                return header.startswith(b'%PDF-')
        except:
            return False
    
    @staticmethod
    def _validate_pdf_structure(file_path: str) -> bool:
        """验证PDF结构"""
        try:
            # Use PyPDF2 for proper validation
            import PyPDF2
            
            with open(file_path, 'rb') as f:
                reader = PyPDF2.PdfReader(f)
                
                # Basic validation
                if len(reader.pages) == 0:
                    return False
                    
                # Check for encrypted PDFs if needed
                if reader.is_encrypted:
                    # Handle encrypted PDFs appropriately
                    pass
                    
                return True
        except:
            return False
    
    @staticmethod
    def sanitize_filename(filename: str) -> str:
        """清理文件名"""
        import re
        # Remove dangerous characters
        filename = re.sub(r'[<>:"/\\|?*]', '', filename)
        # Prevent directory traversal
        filename = filename.replace('..', '')
        # Limit length
        if len(filename) > 255:
            name, ext = os.path.splitext(filename)
            filename = name[:255-len(ext)] + ext
        return filename
```

## 5. Authentication and Authorization

### Current Issue: No Auth System

```python
# Current code has no authentication
def handle_websocket_message(self, client, message):
    # Anyone can connect and perform any action
    message_type = message.get('type')
    if message_type == 'add_pdf':
        self.handle_add_pdf(client, message)  # No auth check!
```

### Recommended Auth Implementation:
```python
class AuthManager:
    def __init__(self, secret_key: str):
        self.secret_key = secret_key
        self.session_store = {}
        
    def create_token(self, user_id: str, permissions: list) -> str:
        """Create JWT token"""
        import jwt
        import time
        
        payload = {
            'user_id': user_id,
            'permissions': permissions,
            'exp': time.time() + 3600,  # 1 hour expiry
            'iat': time.time()
        }
        
        return jwt.encode(payload, self.secret_key, algorithm='HS256')
    
    def validate_token(self, token: str) -> dict:
        """Validate JWT token"""
        try:
            import jwt
            payload = jwt.decode(token, self.secret_key, algorithms=['HS256'])
            
            # Check if session is active
            session_key = f"{payload['user_id']}:{payload['iat']}"
            if session_key not in self.session_store:
                raise ValueError("Session not found")
                
            return payload
        except Exception as e:
            logger.error(f"Token validation failed: {e}")
            return None

# Usage in WebSocket handler
class SecureWebSocketHandler:
    def __init__(self, auth_manager: AuthManager):
        self.auth_manager = auth_manager
        
    def handle_websocket_message(self, client, message):
        # Extract token from message
        token = message.get('auth_token')
        if not token:
            self.send_error(client, "Authentication required")
            return
            
        # Validate token
        auth_data = self.auth_manager.validate_token(token)
        if not auth_data:
            self.send_error(client, "Invalid authentication")
            return
            
        # Check permissions
        message_type = message.get('type')
        if not self._check_permission(auth_data, message_type):
            self.send_error(client, "Insufficient permissions")
            return
            
        # Process message
        self.process_authenticated_message(client, message, auth_data)
```

These code examples demonstrate how to fix the critical security vulnerabilities identified in the review. Each fix includes multiple layers of defense to prevent common attack vectors.