{
  "task-background": {
    "project-name": "Anki LinkMaster PDFJS - PDF.js init reporting",
    "description": "基于 AIforum/20250910231210-solution-001.json 的最终定稿方案，将后端启动时触发前端打开 pdf-viewer 并记录 PDF.js 初始化/加载诊断日志的实现方案拆解为可执行原子任务。",
    "content": "内容总结自 `AIforum/20250910231210-solution-001.json`",
    "refers": [
      "AIforum/20250910231210-solution-001.json",
      "src/backend/websocket/server.py",
      "src/frontend/pdf-viewer/index.js",
      "docs/AI-docs-schema/atom-tasks.example.json"
    ],
    "status": "draft",
    "total-atom-task-count": 9
  },
  "atom-task-list": [
    {
      "id": "AT001",
      "title": "新增后端 pdfjs 日志模块 src/backend/logging/pdfjs_logger.py",
      "description": "创建日志模块 get_pdfjs_logger()，使用 logging + TimedRotatingFileHandler 写入 logs/pdfjs-init.log，按日切分，保留 7 天。模块应可被其他后端模块导入。",
      "estimated_time_minutes": 45,
      "dependencies": [],
      "files_changed": [
        "src/backend/logging/pdfjs_logger.py"
      ],
      "patch": "文件新建: src/backend/logging/pdfjs_logger.py\n内容:\nfrom logging import getLogger, Formatter, StreamHandler\nfrom logging.handlers import TimedRotatingFileHandler\nimport os\n\nLOG_DIR = os.path.join(os.getcwd(), \"logs\")\nos.makedirs(LOG_DIR, exist_ok=True)\nLOG_PATH = os.path.join(LOG_DIR, \"pdfjs-init.log\")\n\ndef get_pdfjs_logger():\n    logger = getLogger(\"pdfjs_init\")\n    if not logger.handlers:\n        handler = TimedRotatingFileHandler(LOG_PATH, when='midnight', backupCount=7, encoding='utf-8')\n        fmt = Formatter('%(asctime)s %(levelname)s %(message)s')\n        handler.setFormatter(fmt)\n        logger.addHandler(handler)\n        logger.setLevel(\"INFO\")\n    return logger\n",
      "required_role": "backend-dev",
      "acceptance_criteria": "文件 src/backend/logging/pdfjs_logger.py 存在且可导入；在本地运行一个小脚本 import get_pdfjs_logger 并写入一条 INFO 日志，logs/pdfjs-init.log 出现该条目，且文件按日命名（或存在）。"
    },
    {
      "id": "AT002",
      "title": "在 WebSocketServer 中新增 broadcast_event 方法",
      "description": "在 src/backend/websocket/server.py 的 WebSocketServer 类中添加 broadcast_event(event_name, payload)，序列化为 JSON 发送给所有连接客户端，处理异常并清理断开连接的客户端引用。",
      "estimated_time_minutes": 40,
      "dependencies": [
        "AT001"
      ],
      "files_changed": [
        "src/backend/websocket/server.py"
      ],
      "patch": "diff -- a/src/backend/websocket/server.py\n+++ b/src/backend/websocket/server.py\n@@\n class WebSocketServer:\n     # existing methods...\n+\n+    def broadcast_event(self, event_name, payload):\n+        \"\"\"Broadcast a JSON event to all connected clients.\"\"\"\n+        import json\n+        msg = json.dumps({\"event\": event_name, \"payload\": payload})\n+        for ws in list(self.connected_clients):\n+            try:\n+                ws.send(msg)\n+            except Exception:\n+                # remove closed client\n+                try:\n+                    self.connected_clients.remove(ws)\n+                except Exception:\n+                    pass\n@@\n",
      "required_role": "backend-dev",
      "acceptance_criteria": "方法 broadcast_event 已添加并通过静态检查；在测试环境启动 WebSocketServer 并连接一个测试客户端后，调用 broadcast_event 能够在客户端收到包含 event 字段的 JSON 消息；断开客户端后不会抛出未捕获异常。"
    },
    {
      "id": "AT003",
      "title": "在后端启动入口 application.py 中触发 open_pdf_viewer 事件",
      "description": "在 src/backend/app/application.py 的 AnkiLinkMasterApp.start()（或等效启动函数）完成服务启动后，导入 get_global_ws_server/get_pdfjs_logger 并使用 ws.broadcast_event('open_pdf_viewer', payload) 通知前端；异常时写入日志并继续启动流程。",
      "estimated_time_minutes": 60,
      "dependencies": [
        "AT001",
        "AT002"
      ],
      "files_changed": [
        "src/backend/app/application.py"
      ],
      "patch": "补丁片段（按 solution 中 diff）:\n在 AnkiLinkMasterApp.start() 中新增：\n    # NEW: notify frontend to open pdf-viewer after backend ready\n    try:\n        from src.backend.websocket.server import get_global_ws_server\n        from src.backend.logging.pdfjs_logger import get_pdfjs_logger\n\n        ws = get_global_ws_server()\n        if ws:\n            payload = {\"action\": \"open_pdf_viewer\", \"timestamp\": datetime.utcnow().isoformat()}\n            ws.broadcast_event(\"open_pdf_viewer\", payload)\n            get_pdfjs_logger().info(\"Sent open_pdf_viewer event to frontend\")\n    except Exception as e:\n        import logging\n        logging.getLogger(\"pdfjs_init\").exception(\"Failed to notify frontend: %s\", e)\n\n(注: 请在文件顶部确保导入 datetime 或按模块规范使用 datetime.utcnow())",
      "required_role": "backend-dev",
      "acceptance_criteria": "在后端应用启动流程中执行后，logs/pdfjs-init.log 中出现 'Sent open_pdf_viewer event to frontend' 条目；若 WebSocket 未就绪，异常被捕获且不会阻塞启动。"
    },
    {
      "id": "AT004",
      "title": "前端：建立后端报告通道并监听 open_pdf_viewer（src/frontend/pdf-viewer/index.js）",
      "description": "在前端 pdf-viewer 的主 JS 初始化代码中新增 setupBackendReporting()，建立到 ws://localhost:8765 的 WebSocket 连接，监听 message 中的 'open_pdf_viewer' 事件并在接收时调用 openPdfViewer()；提供 window.reportPdfjsInit(statusObj) 函数用于上报初始化结果，若 WebSocket 未打开则回退到 HTTP POST /api/pdfjs/init-status。",
      "estimated_time_minutes": 50,
      "dependencies": [],
      "files_changed": [
        "src/frontend/pdf-viewer/index.js"
      ],
      "patch": "在现有文件中插入（片段基于 solution 中 diff）：\n// NEW: connect to backend websocket to receive open_pdf_viewer and report PDF.js init status\nfunction setupBackendReporting() {\n    try {\n        const ws = new WebSocket('ws://localhost:8765');\n        ws.addEventListener('open', () => { console.info('ws connected to backend for pdfjs init reporting'); });\n        ws.addEventListener('message', (ev) => {\n            try {\n                const msg = JSON.parse(ev.data);\n                if (msg.event === 'open_pdf_viewer') { openPdfViewer(); }\n            } catch(e) { console.error(e); }\n        });\n        window.reportPdfjsInit = function(statusObj) {\n            const payload = {event: 'pdfjs_init_status', payload: statusObj};\n            if (ws.readyState === WebSocket.OPEN) {\n                ws.send(JSON.stringify(payload));\n            } else {\n                fetch('/api/pdfjs/init-status', {method: 'POST', headers: {'Content-Type':'application/json'}, body: JSON.stringify(statusObj)}).catch(()=>{});\n            }\n        };\n    } catch (e) { console.error('failed to setup backend reporting', e); }\n}\nsetupBackendReporting();\n\n并在 PDF.js 成功/失败回调处调用 window.reportPdfjsInit(...)。",
      "required_role": "frontend-dev",
      "acceptance_criteria": "前端文件已修改并在浏览器中加载时尝试建立 ws 连接；在收到模拟的 open_pdf_viewer 消息时调用 openPdfViewer()（可通过控制台日志验证）；在 pdfjs 成功/失败回调调用 window.reportPdfjsInit 能触发 WebSocket 发送或 HTTP POST（可在浏览器 network/console 观察）。"
    },
    {
      "id": "AT005",
      "title": "后端：在 WebSocket 消息处理处接收 pdfjs_init_status 并写日志",
      "description": "在 src/backend/websocket/server.py 的消息处理逻辑中，当收到客户端消息并解析出 event == 'pdfjs_init_status' 时，调用 get_pdfjs_logger().info(f\"PDFJS_INIT {payload}\") 写入日志。",
      "estimated_time_minutes": 30,
      "dependencies": [
        "AT001",
        "AT002",
        "AT004"
      ],
      "files_changed": [
        "src/backend/websocket/server.py"
      ],
      "patch": "片段（插入位置：处理收到消息的代码块）:\nif msg.get('event') == 'pdfjs_init_status':\n    payload = msg.get('payload', {})\n    from src.backend.logging.pdfjs_logger import get_pdfjs_logger\n    logger = get_pdfjs_logger()\n    logger.info(f\"PDFJS_INIT {payload}\")\n",
      "required_role": "backend-dev",
      "acceptance_criteria": "当前端发送 pdfjs_init_status 消息到 WebSocket 时，后端 logs/pdfjs-init.log 出现包含 'PDFJS_INIT' 的条目，消息内容中包含 status 字段。"
    },
    {
      "id": "AT006",
      "title": "后端（HTTP 备选）：实现 POST 接收端 src/backend/api/pdfjs_status.py",
      "description": "新增轻量 HTTP POST 接收端，示例使用 Flask Blueprint（或项目使用的框架），路由 /api/pdfjs/init-status 接收 JSON 并写入 pdfjs 日志模块。仅作为 WebSocket 不可用时的回退方案。",
      "estimated_time_minutes": 45,
      "dependencies": [
        "AT001"
      ],
      "files_changed": [
        "src/backend/api/pdfjs_status.py",
        "（如需）后端路由注册处"
      ],
      "patch": "新文件示例内容:\nfrom flask import Blueprint, request, jsonify\nfrom src.backend.logging.pdfjs_logger import get_pdfjs_logger\nbp = Blueprint('pdfjs', __name__)\n@bp.route('/api/pdfjs/init-status', methods=['POST'])\ndef pdfjs_init_status():\n    data = request.get_json() or {}\n    logger = get_pdfjs_logger()\n    logger.info(f\"PDFJS_INIT {data}\")\n    return jsonify({'ok': True}), 200\n\n(注意: 若后端不是 flask，请按实际框架实现等价路由并注册到 app)",
      "required_role": "backend-dev",
      "acceptance_criteria": "POST /api/pdfjs/init-status 能接受 JSON 并写入 logs/pdfjs-init.log 中的 PDFJS_INIT 条目（通过 curl 或 Postman 验证）。"
    },
    {
      "id": "AT007",
      "title": "集成测试：用本地集成脚本验证从启动到日志写入的流程（WebSocket 路径）",
      "description": "编写并运行一个集成测试脚本或手动步骤：启动后端（可用 ai-launcher.ps1），启动前端（或模拟前端 ws 客户端），确认后端在启动阶段广播 open_pdf_viewer，前端接收并上报 pdfjs_init_status，后端 logs/pdfjs-init.log 收到条目。",
      "estimated_time_minutes": 90,
      "dependencies": [
        "AT001",
        "AT002",
        "AT003",
        "AT004",
        "AT005"
      ],
      "files_changed": [
        "AItemp/tests/integration_pdfjs_init.sh (建议新脚本或 README 指令)"
      ],
      "patch": "建议步骤 (可写入 AItemp/ 脚本):\n1) git checkout -b feat/pdfjs-init-test\n2) 启动后端: .\\ai-launcher.ps1 start\n3) 观察 logs/pdfjs-init.log 包含 'Sent open_pdf_viewer event to frontend'\n4) 使用一个轻量前端模拟器或在真实前端中确认 open_pdf_viewer 被接收\n5) 前端在 pdfjs 初始化处调用 window.reportPdfjsInit({status:'success', pages:1, timestamp:...})\n6) 验证 logs/pdfjs-init.log 包含 'PDFJS_INIT' 记录\n",
      "required_role": "tester",
      "acceptance_criteria": "完整测试流程运行成功：后端启动日志包含广播记录；前端接收广播并上报；后端日志文件出现 PDFJS_INIT success 条目。"
    },
    {
      "id": "AT008",
      "title": "docs & 操作说明：更新 apply instructions / ai-launcher 使用说明",
      "description": "在 docs 或 README 中追加部署/测试说明，列出如何开启 ai-launcher.ps1、必要配置（WebSocket 端口）、如何手动触发前端上报和检查 logs/pdfjs-init.log 的位置及示例日志条目。",
      "estimated_time_minutes": 30,
      "dependencies": [
        "AT001",
        "AT003",
        "AT004"
      ],
      "files_changed": [
        "docs/操作说明/README-pdfjs-init.md"
      ],
      "patch": "新增文档片段，包含启动步骤、测试步骤与预期日志示例（参考 solution 中 test_steps 与 expected_log_examples）。",
      "required_role": "devops",
      "acceptance_criteria": "新增文档存在且能指导他人在本地复现完整流程；文档包含示例日志与排错建议。"
    },
    {
      "id": "AT009",
      "title": "代码审查与合并：在分支上提交变更并通过 CI/测试后合并主干",
      "description": "为变更创建 git 分支、提交所有修改，运行项目已有单元/集成测试（或新增必要测试），发起 Pull Request 并完成代码审查与合并流程。",
      "estimated_time_minutes": 60,
      "dependencies": [
        "AT001",
        "AT002",
        "AT003",
        "AT004",
        "AT005",
        "AT006",
        "AT007",
        "AT008"
      ],
      "files_changed": [
        "（所有上述变更文件）"
      ],
      "patch": "工作流程指引：\n- git checkout -b feat/pdfjs-init-logging\n- git add <modified files>\n- git commit -m \"feat: pdfjs init reporting via ws + logging\"\n- push & create PR\n- 等待 code review & CI\n- merge\n",
      "required_role": "project-manager",
      "acceptance_criteria": "PR 已提交并通过 CI/测试，审阅者已同意合并；变更合并到主分支并在主分支上复现 acceptance 测试结果。"
    }
  ]
}