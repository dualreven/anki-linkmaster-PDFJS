1) 避免在子组件中清空宿主容器：不要使用 container.innerHTML = '' 来处理空/错状态，改为在组件的内部插槽（如 tableWrapper）中更新内容，或用显示/隐藏而非移除 DOM 元素。

2) 明确容器职责边界：将 container（外壳）与 tableWrapper（内容插槽）职责区分开，所有渲染器只向 tableWrapper 写入内容，所有外壳级别的结构变更要通过公有方法（如 setupContainer 或 getOrCreateWrapper）完成并同时更新内部引用。

3) 事件监听管理：在组件的初始化阶段注册一次必要事件，确保不会在每次渲染或数据刷新时重复注册；在 destroy 时清理监听器。

4) 渲染器防御性设计：渲染器在写入前应检查目标插槽是否仍挂载到期望的容器，若发现异常应尝试重建或重新挂载，并记录足够的调试信息便于回溯。

5) 日志与快照策略：在重要步骤（初始化、收到数据、渲染前、渲染后）输出一致格式的快照信息（包括 container selector、container.innerHTML 前若干字符、子元素数量、渲染器的 rowCount）。这有助于快速判断是数据问题、渲染问题还是 DOM 操作问题。

6) 测试覆盖：为 PDFTable 编写集成测试用例，覆盖以下场景：
   - 初始化后调用 displayEmptyState 多次，再 loadData，验证 tableWrapper 始终存在并被正确填充。
   - 在重复发布 pdf:list:updated 时，确保 UIManager 不会重复注册事件（可通过断言事件处理器调用次数）。

7) 代码审查规范：在 PR checklist 中加入禁止随意清空宿主容器的条目，以及要求对所有 DOM 结构修改写明恢复策略（如果删除了子元素，需要说明如何恢复内部引用）。


---

前后端通信原理（添加/删除）

概述
- 本项目的添加/删除功能基于事件驱动与异步消息传递：UI 发出用户意图 → 本地事件总线分发 → 管理器组装并发送消息到后端 → 后端执行并返回结果/广播 → 前端接收并更新 UI。

核心原则（高层）
- 明确责任链：UI 负责收集用户意图并触发本地事件；管理层负责把事件转为可靠的对外消息；网络层负责实际传输并报告传输结果；后端负责执行并在变更后广播状态更新。
- 可追溯性：每次交互应带可追溯 metadata（调用者标识、唯一请求 id 或 trace token），便于从 UI 一端追溯到后端处理结果并排查问题。
- 幂等与确认：对可能被重复发出的操作（删除、添加确认）设计为幂等或通过唯一请求 id 实现幂等保证；仅在收到明确成功确认后再更新关键本地状态或以广播结果为准。
- 防御性更新：后端响应可能为空或为局部信息，前端不应盲目用空数组覆盖本地列表；遇到模糊响应时应主动拉取完整列表以重建一致性。
- 向后兼容：在迁移期间前端应同时提交可辨识资源的多种标识（例如唯一 id 与可读名称），后端以唯一 id 为优先处理依据并兼容名称匹配作为回退。

添加功能的典型底层流程（概念）
- 步骤：UI 请求文件选择或上传 → 前端通过事件触发管理器发送“请求选择/上传”的消息 → 后端（或本地托管进程）弹出选择器或接收上传并持久化 → 后端返回添加结果与摘要 → 管理器收到结果并触发本地列表刷新或广播。
- 要点：添加常常是多步的（交互式选择 + 后端确认），需要 request_id/summary 来表明实际被添加的数量与失败项；若添加成功，应触发完整列表刷新或广播以保持视图一致。

删除功能的典型底层流程（概念）
- 步骤：UI 发起删除（携带资源标识）→ 本地事件总线转发到管理器 → 管理器构建删除消息并通过网络发送到后端 → 后端执行删除并返回确认/失败详情 → 后端通常会广播更新后的列表或管理器在确认后请求完整列表。
- 要点：删除应以唯一标识为主（id），但为兼容性可同时提交名称作为回退；删除必须有明确确认（成功/失败），前端在收到成功后再更新本地视图或等待后端广播。


每当你要修改一个模块时,你必须先阅读这个模块的开发规范, 通常他保存在 [模块名]/docs/SPEC 下面, 特别注意有个头文件 [模块名]/docs/SPEC/SPEC-HEAD-[模块名].yml 他记录了所有引用的规范, 必须先阅读规范, 然后遵守规范来修改和测试代码

此外你不需要 `npm run dev` 通常 开发环境都已经启动好了, 比如为了查看前端的console输出,我们需要启动三个东西 `npm run dev`,`python app.py`,`python debug.py`. 通常都启动好了

每次开始修改代码的任务前, 你必须先和用户商议讨论你的计划, 然后通过用户的许可后, 开始git commit, 然后创建分支, 保存快照, 然后再进行修改, 修改通过后, 通过用户的认可再commit, 再合并分支到来时的分支, 如果修改导致更恶劣的情况发生,应当立即退回修改.

