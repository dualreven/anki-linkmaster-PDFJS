---
基本规则:
   - 总是使用中文回复.

文件修改时的注意事项: 
   必须遵守和阅读开发规范: 每当你要修改一个模块时,你必须先阅读这个模块的开发规范, 通常他保存在 [模块名]/docs/SPEC 下面, 特别注意有个头文件 [模块名]/docs/SPEC/SPEC-HEAD-[模块名].yml 他记录了所有引用的规范, 必须先阅读规范, 然后遵守规范来修改和测试代码.
   与用户商量你的修改计划: 每次开始修改代码的任务前, 你必须先和用户商议讨论你的计划.
   修改前提交git创建分支: 通过用户的许可后, 先git commit, 然后创建分支, 保存快照, 然后再进行修改
   失败回滚git: 如果修改导致更恶劣的情况发生,应当立即退回修改
   成功提交git合并分支: 修改通过后, 通过用户的认可再commit, 再合并分支到来时的分支

测试代码时的注意事项:
   无需配置环境: 通常开发环境都已经启动好了, 比如为了查看前端的console输出,我们需要启动三个东西 `npm run dev`,`python app.py`,`python debug.py`. 通常都启动好了,你无需配置这些环境
   前端测试的途径: 这个项目的前端页面运行在qtwebengine上, 用vite管理组织代码文件的路由问题, 通过 debug-console-at-9222.log 可以文件看到 pdf-home页面的控制台消息.

debug代码时的注意事项:
   debug的逆向思维: 从与用户使用行为最近的代码开始检查bug, 比如表格渲染不正常, 则直接看表格渲染的问题, 确定表格渲染的正确性, 如果正常, 再回推别的问题. 

本项目的前后端通信原理（添加/删除）:
   概述: 本项目的添加/删除功能基于事件驱动与异步消息传递：UI 发出用户意图 → 本地事件总线分发 → 管理器组装并发送消息到后端 → 后端执行并返回结果/广播 → 前端接收并更新 UI。
   核心原则（高层）:
      - 明确责任链：UI 负责收集用户意图并触发本地事件；管理层负责把事件转为可靠的对外消息；网络层负责实际传输并报告传输结果；后端负责执行并在变更后广播状态更新。
      - 可追溯性：每次交互应带可追溯 metadata（调用者标识、唯一请求 id 或 trace token），便于从 UI 一端追溯到后端处理结果并排查问题。
      - 幂等与确认：对可能被重复发出的操作（删除、添加确认）设计为幂等或通过唯一请求 id 实现幂等保证；仅在收到明确成功确认后再更新关键本地状态或以广播结果为准。
      - 防御性更新：后端响应可能为空或为局部信息，前端不应盲目用空数组覆盖本地列表；遇到模糊响应时应主动拉取完整列表以重建一致性。
      - 向后兼容：在迁移期间前端应同时提交可辨识资源的多种标识（例如唯一 id 与可读名称），后端以唯一 id 为优先处理依据并兼容名称匹配作为回退。

   添加功能的典型底层流程（概念）:
      - 步骤：UI 请求文件选择或上传 → 前端通过事件触发管理器发送“请求选择/上传”的消息 → 后端（或本地托管进程）弹出选择器或接收上传并持久化 → 后端返回添加结果与摘要 → 管理器收到结果并触发本地列表刷新或广播。
      - 要点：添加常常是多步的（交互式选择 + 后端确认），需要 request_id/summary 来表明实际被添加的数量与失败项；若添加成功，应触发完整列表刷新或广播以保持视图一致。

   删除功能的典型底层流程（概念）:
      - 步骤：UI 发起删除（携带资源标识）→ 本地事件总线转发到管理器 → 管理器构建删除消息并通过网络发送到后端 → 后端执行删除并返回确认/失败详情 → 后端通常会广播更新后的列表或管理器在确认后请求完整列表。
      - 要点：删除应以唯一标识为主（id），但为兼容性可同时提交名称作为回退；删除必须有明确确认（成功/失败），前端在收到成功后再更新本地视图或等待后端广播。

代码工程化思想:
   传入变量应无外部副作用: 函数接受的参数应当是不可变的, 该变量作为副本传入, 外部修改该变量不会影响其在函数内部的状态.
   必须写注释: 不管是js还是py,编写任何函数都要先写文档,描述用法和输入输出.