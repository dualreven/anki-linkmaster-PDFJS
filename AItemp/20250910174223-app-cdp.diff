--- a/app.py
+++ b/app.py
@@
-import sys
-from src.backend.main import main
-
-if __name__ == "__main__":
-    exit_code = main()
-    sys.exit(exit_code)
+import sys
+import threading
+import asyncio
+import json
+import os
+import urllib.request
+from datetime import datetime
+
+from src.backend.main import main
+
+class DevToolsLogCollector:
+    '''
+    Background collector that connects to QtWebEngine's remote debugging (CDP)
+    and writes Console/Runtime/Page events to logs/pdf-viewer.log as JSON-lines.
+    '''
+    def __init__(self, ports=None, poll_interval=2, log_file=None):
+        self.ports = ports or [9222, 9223]
+        self.poll_interval = poll_interval
+        self.log_file = log_file or os.path.join(os.getcwd(), 'logs', 'pdf-viewer.log')
+        self._stop_event = threading.Event()
+        self._thread = None
+
+    def start(self):
+        log_dir = os.path.dirname(self.log_file)
+        if log_dir and not os.path.exists(log_dir):
+            os.makedirs(log_dir, exist_ok=True)
+        self._thread = threading.Thread(target=self._run, daemon=True, name='DevToolsLogCollector')
+        self._thread.start()
+
+    def stop(self):
+        self._stop_event.set()
+        if self._thread and self._thread.is_alive():
+            self._thread.join(timeout=1.0)
+
+    def _run(self):
+        try:
+            asyncio.run(self._async_main())
+        except Exception as e:
+            print(f'[DevToolsLogCollector] failed: {e}', file=sys.stderr)
+
+    async def _async_main(self):
+        try:
+            import websockets
+            websockets_available = True
+        except Exception as e:
+            websockets_available = False
+            self._write_log({
+                'timestamp': datetime.utcnow().isoformat() + 'Z',
+                'event': 'collector.info',
+                'details': f'websockets library not available: {e}'
+            })
+
+        while not self._stop_event.is_set():
+            targets = []
+            for port in self.ports:
+                try:
+                    url = f'http://127.0.0.1:{port}/json'
+                    resp = await asyncio.to_thread(urllib.request.urlopen, url, timeout=1)
+                    raw = await asyncio.to_thread(resp.read)
+                    try:
+                        targets = json.loads(raw.decode('utf-8'))
+                    except Exception:
+                        targets = []
+                    if targets:
+                        break
+                except Exception:
+                    continue
+
+            if not targets:
+                await asyncio.sleep(self.poll_interval)
+                continue
+
+            try:
+                self._write_log({
+                    'timestamp': datetime.utcnow().isoformat() + 'Z',
+                    'event': 'targets.discovered',
+                    'details': [{'url': t.get('url'), 'webSocketDebuggerUrl': t.get('webSocketDebuggerUrl')} for t in targets]
+                })
+            except Exception:
+                pass
+
+            if not websockets_available:
+                await asyncio.sleep(self.poll_interval)
+                continue
+
+            ws_url = None
+            for t in targets:
+                url = (t.get('url') or '').lower()
+                if 'pdf-viewer' in url:
+                    ws_url = t.get('webSocketDebuggerUrl')
+                    break
+            if not ws_url:
+                ws_url = targets[0].get('webSocketDebuggerUrl')
+            if not ws_url:
+                await asyncio.sleep(self.poll_interval)
+                continue
+
+            try:
+                async with websockets.connect(ws_url) as ws:
+                    await ws.send(json.dumps({'id': 1, 'method': 'Runtime.enable'}))
+                    await ws.send(json.dumps({'id': 2, 'method': 'Console.enable'}))
+                    await ws.send(json.dumps({'id': 3, 'method': 'Page.enable'}))
+
+                    while not self._stop_event.is_set():
+                        try:
+                            msg = await asyncio.wait_for(ws.recv(), timeout=1.0)
+                        except asyncio.TimeoutError:
+                            continue
+                        try:
+                            payload = json.loads(msg)
+                        except Exception:
+                            payload = {'raw': msg}
+
+                        self._write_log({
+                            'timestamp': datetime.utcnow().isoformat() + 'Z',
+                            'event': payload.get('method') or 'message',
+                            'details': payload.get('params') if isinstance(payload, dict) else payload
+                        })
+            except Exception as e:
+                self._write_log({
+                    'timestamp': datetime.utcnow().isoformat() + 'Z',
+                    'event': 'connection.error',
+                    'details': str(e)
+                })
+                await asyncio.sleep(1.0)
+
+    def _write_log(self, entry):
+        try:
+            with open(self.log_file, 'a', encoding='utf-8') as f:
+                f.write(json.dumps(entry, ensure_ascii=False) + '\n')
+        except Exception as e:
+            print(f'[DevToolsLogCollector] failed to write log: {e}', file=sys.stderr)
+
+
+_collector = DevToolsLogCollector()
+_collector.start()
+
+if __name__ == '__main__':
+    try:
+        exit_code = main()
+    finally:
+        try:
+            _collector.stop()
+        except Exception:
+            pass
+    sys.exit(exit_code)