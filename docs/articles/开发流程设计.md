我之所以把事情拆分的那么细致,是为了保持一致性, 如果智能体把工作结果以文档形式保留下来,就能在任务中断后快速重新回复到当时的情景.

0-Project-Manager
- 流程：需求澄清与目标定义 → 原型迭代计划(把目标分成多个原型版本逐步迭代趋近) → 启动原型迭代开发（Proto-Iter-Dev）
- 输入：用户自然语言需求
- 输出：
  - 0.1 需求对齐文档
  - 0.2 原型迭代目标说明
  - 0.3 启动指令（进入 1-Proto-Iter-Dev）

1-Proto-Iter-Developer
- 流程：从原型计划中选择原型版本→创建迭代分支 → 调用 ArchSpec-Manager → 调用 Task-Design-Manager → 对每个分组调用 Group-Job-Manager → 迭代验收 → 合并分支
- 输入：0.1 需求对齐文档，0.2 原型迭代目标说明
- 输出：
  - 1.1 架构说明（来自 1.1.1.1）
  - 1.2 规范说明（来自 1.1.1.2）
  - 1.3 架构与规范一致性验收报告（来自 1.1.1.3）
  - 1.4 原子任务列表（来自 1.2.1）
  - 1.5 测试用例集（来自 1.2.1.1 汇总）
  - 1.6 分组计划（来自 1.2）
  - 1.7 分组任务执行结果（来自 1.3）
  - 1.8 迭代验收报告（本节点产出）

1.1-ArchSpec-Manager
- 流程：调用 Arch-Designer → 调用 Spec-Designer → Conflict-Detector 验收
- 输入：0.1 需求对齐文档，0.2 原型迭代目标说明
- 输出：
  - 1.1.1 架构说明（转 1.1.1.1 产物）
  - 1.1.2 规范说明（转 1.1.1.2 产物）
  - 1.1.3 架构与规范一致性验收报告（转 1.1.1.3 产物）

1.1.1-Arch-Designer
- 流程：架构生成/调整
- 输入：0.1 需求对齐文档，0.2 原型迭代目标说明
- 输出：1.1.1 架构说明

1.1.2-Spec-Designer
- 流程：规范生成/调整（编码规范、API 风格、错误码、日志、性能/安全/合规约束等）
- 输入：0.1 需求对齐文档，0.2 原型迭代目标说明
- 输出：1.1.2 规范说明

1.1.3-Conflict-Detector
- 流程：检测架构与规范冲突，给出是否通过及问题清单
- 输入：0.1 需求对齐文档，0.2 原型迭代目标说明，1.1.1 架构说明，1.1.2 规范说明
- 输出：1.1.3 架构与规范一致性验收报告

1.2-Task-Design-Manager
- 流程：基于需求/目标/架构/规范进行
  1) 接口用例设计
  2) 原子化任务拆解
  3) 分组与计划编排
  4) 为每个原子任务调用 Test-Designer 生成测试
- 输入：0.1 需求对齐文档，0.2 原型迭代目标说明，1.1.1 架构说明，1.1.2 规范说明
- 输出：
  - 1.2.1 原子任务列表（含任务依赖、完成定义 DoD、估时）
  - 1.2.2 接口用例集
  - 1.2.3 分组计划（分组任务文档）
  - 1.2.4 测试用例集（聚合 1.2.1.1 产物）

1.2.1-Test-Designer
- 流程：为每个原子任务设计测试（单元/契约/集成/回归/验收）
- 输入：0.1，0.2，1.1.1，1.1.2，1.2.1 原子任务列表
- 输出：1.2.1.1 原子任务测试用例与测试数据

1.3-Group-Job-Manager
- 流程：按分组计划对每个原子任务调用 Job-Executor；汇总结果
- 输入：0.2 原型迭代目标说明，1.1.1 架构说明，1.1.2 规范说明，1.2.2 接口用例集，1.2.1 原子任务列表（分组子集），1.2.4 测试用例集（分组子集）
- 输出：1.3 分组任务执行结果（含通过率、缺陷清单、工时消耗）

1.3.1-Job-Executor
- 流程：对单个原子任务 → Code-Generator → Test-Verifier → Spec-Verifier → 产出结果
- 输入：0.2，1.1.1，1.1.2，1.2.2（相关接口用例），1.2.1（单个原子任务），1.2.1.1（对应测试）
- 输出：1.3.1 原子任务执行结果（含构建产物、日志、状态）

1.3.1.1-Code-Generator
- 流程：生成/修改代码与脚本
- 输入：同 1.3.1
- 输出：1.3.1.1 代码工件（源码、配置、迁移脚本等）

1.3.1.2-Test-Verifier
- 流程：执行测试并产出报告
- 输入：同 1.3.1，附 1.3.1.1 代码工件
- 输出：1.3.1.2 测试验证报告（覆盖率、通过/失败、日志）

1.3.1.3-Spec-Verifier
- 流程：验证规范约束（样式、静态扫描、安全、性能阈值等）
- 输入：同 1.3.1，附 1.3.1.1 代码工件
- 输出：1.3.1.3 规范验证报告（规则通过率、违规清单）

1.4-Iteration-Acceptance
- 流程：由 Proto-Iter-Developer 组织，对 1.3 结果进行验收评审（需求满足度、质量门禁、回归风险、剩余缺陷、发布建议）
- 输入：0.1，0.2，1.3 分组任务执行结果，1.3.1.2 测试验证报告（汇总），1.3.1.3 规范验证报告（汇总）
- 输出：1.4 迭代验收报告（通过/否；问题与行动项；是否合并与发布）